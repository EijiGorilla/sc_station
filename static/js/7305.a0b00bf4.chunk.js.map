{"version":3,"file":"static/js/7305.a0b00bf4.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/src/components/tree/utils.ts","../node_modules/@esri/calcite-components/dist/components/src/components/tree/tree.scss?tag=calcite-tree&encapsulation=shadow","../node_modules/@esri/calcite-components/dist/components/src/components/tree/tree.tsx"],"sourcesContent":["export function isTreeItem(element: Element): element is HTMLCalciteTreeItemElement {\n  return element?.tagName === \"CALCITE-TREE-ITEM\";\n}\n\nexport function getTraversableItems(root: HTMLCalciteTreeElement): HTMLCalciteTreeItemElement[] {\n  return Array.from(root.querySelectorAll<HTMLCalciteTreeItemElement>(\"calcite-tree-item:not([disabled])\")).filter(\n    (item): boolean => {\n      let currentItem: HTMLElement = item;\n\n      while (currentItem !== root && currentItem !== undefined) {\n        const parent = currentItem.parentElement;\n        const traversable = !isTreeItem(parent) || !parent.hasChildren || parent.expanded;\n\n        if (!traversable) {\n          return false;\n        }\n\n        currentItem = currentItem.parentElement;\n      }\n\n      return true;\n    },\n  );\n}\n",":host {\n  @apply block;\n}\n\n:host(:focus) {\n  @apply outline-none;\n}\n\n@include base-component();\n","import {\n  Component,\n  Element,\n  Event,\n  EventEmitter,\n  h,\n  Host,\n  Listen,\n  Prop,\n  VNode,\n} from \"@stencil/core\";\nimport { focusElement, nodeListToArray, toAriaBoolean } from \"../../utils/dom\";\nimport { Scale, SelectionMode } from \"../interfaces\";\nimport { TreeItemSelectDetail } from \"../tree-item/interfaces\";\nimport { getTraversableItems, isTreeItem } from \"./utils\";\n\n/**\n * @slot - A slot for `calcite-tree-item` elements.\n */\n@Component({\n  tag: \"calcite-tree\",\n  styleUrl: \"tree.scss\",\n  shadow: true,\n})\nexport class Tree {\n  //--------------------------------------------------------------------------\n  //\n  //  Properties\n  //\n  //--------------------------------------------------------------------------\n\n  /** When `true`, displays indentation guide lines. */\n  @Prop({ mutable: true, reflect: true }) lines = false;\n\n  /**\n   * @internal\n   */\n  @Prop({ reflect: true, mutable: true }) child: boolean;\n\n  /** Specifies the size of the component. */\n  @Prop({ mutable: true, reflect: true }) scale: Scale = \"m\";\n\n  /**\n   * Specifies the selection mode of the component, where:\n   *\n   * `\"ancestors\"` displays with a checkbox and allows any number of selections from corresponding parent and child selections,\n   *\n   * `\"children\"` allows any number of selections from one parent from corresponding parent and child selections,\n   *\n   * `\"multichildren\"` allows any number of selections from corresponding parent and child selections,\n   *\n   * `\"multiple\"` allows any number of selections,\n   *\n   * `\"none\"` allows no selections,\n   *\n   * `\"single\"` allows one selection, and\n   *\n   * `\"single-persist\"` allows and requires one selection.\n   *\n   * @default \"single\"\n   */\n  @Prop({ mutable: true, reflect: true }) selectionMode: SelectionMode = \"single\";\n\n  /**\n   * Specifies the component's selected items.\n   *\n   * @readonly\n   */\n  @Prop({ mutable: true }) selectedItems: HTMLCalciteTreeItemElement[] = [];\n\n  //--------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  //--------------------------------------------------------------------------\n\n  componentWillRender(): void {\n    const parent: HTMLCalciteTreeElement = this.el.parentElement?.closest(\"calcite-tree\");\n    this.lines = parent ? parent.lines : this.lines;\n    this.scale = parent ? parent.scale : this.scale;\n    this.selectionMode = parent ? parent.selectionMode : this.selectionMode;\n    this.child = !!parent;\n  }\n\n  render(): VNode {\n    return (\n      <Host\n        aria-multiselectable={\n          this.child\n            ? undefined\n            : toAriaBoolean(\n                this.selectionMode === \"multiple\" || this.selectionMode === \"multichildren\",\n              )\n        }\n        onKeyDown={this.keyDownHandler}\n        role={!this.child ? \"tree\" : undefined}\n        tabIndex={this.getRootTabIndex()}\n      >\n        <slot />\n      </Host>\n    );\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Event Listeners\n  //\n  //--------------------------------------------------------------------------\n\n  @Listen(\"focus\") onFocus(): void {\n    if (!this.child) {\n      const focusTarget =\n        this.el.querySelector<HTMLCalciteTreeItemElement>(\n          \"calcite-tree-item[selected]:not([disabled])\",\n        ) || this.el.querySelector<HTMLCalciteTreeItemElement>(\"calcite-tree-item:not([disabled])\");\n\n      focusElement(focusTarget);\n    }\n  }\n\n  @Listen(\"focusin\") onFocusIn(event: FocusEvent): void {\n    const focusedFromRootOrOutsideTree =\n      event.relatedTarget === this.el || !this.el.contains(event.relatedTarget as HTMLElement);\n\n    if (focusedFromRootOrOutsideTree) {\n      // gives user the ability to tab into external elements (modifying tabindex property will not work in firefox)\n      this.el.removeAttribute(\"tabindex\");\n    }\n  }\n\n  @Listen(\"focusout\") onFocusOut(event: FocusEvent): void {\n    const willFocusOutsideTree = !this.el.contains(event.relatedTarget as HTMLElement);\n\n    if (willFocusOutsideTree) {\n      this.el.tabIndex = this.getRootTabIndex();\n    }\n  }\n\n  @Listen(\"calciteInternalTreeItemSelect\")\n  onInternalTreeItemSelect(event: CustomEvent<TreeItemSelectDetail>): void {\n    if (this.child) {\n      return;\n    }\n\n    const target = event.target as HTMLCalciteTreeItemElement;\n    const childItems = nodeListToArray(target.querySelectorAll(\"calcite-tree-item\"));\n\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (this.selectionMode === \"ancestors\") {\n      this.updateAncestorTree(event);\n      return;\n    }\n\n    const isNoneSelectionMode = this.selectionMode === \"none\";\n\n    const shouldSelect =\n      this.selectionMode !== null &&\n      (!target.hasChildren ||\n        (target.hasChildren &&\n          (this.selectionMode === \"children\" || this.selectionMode === \"multichildren\")));\n\n    const shouldDeselectAllChildren = this.selectionMode === \"multichildren\" && target.hasChildren;\n\n    const shouldModifyToCurrentSelection =\n      !isNoneSelectionMode &&\n      event.detail.modifyCurrentSelection &&\n      (this.selectionMode === \"multiple\" || this.selectionMode === \"multichildren\");\n\n    const shouldClearCurrentSelection =\n      !shouldModifyToCurrentSelection &&\n      (((this.selectionMode === \"single\" || this.selectionMode === \"multiple\") &&\n        childItems.length <= 0) ||\n        this.selectionMode === \"children\" ||\n        this.selectionMode === \"multichildren\" ||\n        (this.selectionMode === \"single-persist\" && !target.hasChildren));\n\n    const shouldUpdateExpand =\n      [\"multiple\", \"none\", \"single\", \"single-persist\"].includes(this.selectionMode) &&\n      target.hasChildren;\n\n    const targetItems: HTMLCalciteTreeItemElement[] = [];\n\n    if (shouldSelect) {\n      targetItems.push(target);\n    }\n\n    if (shouldClearCurrentSelection) {\n      const selectedItems = nodeListToArray(\n        this.el.querySelectorAll<HTMLCalciteTreeItemElement>(\"calcite-tree-item[selected]\"),\n      );\n\n      selectedItems.forEach((treeItem) => {\n        if (!targetItems.includes(treeItem)) {\n          treeItem.selected = false;\n        }\n      });\n    }\n\n    if (\n      shouldUpdateExpand &&\n      [\"multiple\", \"none\", \"single\", \"single-persist\"].includes(this.selectionMode)\n    ) {\n      target.expanded = !target.expanded;\n    }\n\n    if (shouldDeselectAllChildren) {\n      childItems.forEach((item) => {\n        item.selected = false;\n        if (item.hasChildren) {\n          item.expanded = false;\n        }\n      });\n    }\n\n    if (shouldModifyToCurrentSelection) {\n      window.getSelection().removeAllRanges();\n    }\n\n    if (shouldModifyToCurrentSelection && target.selected) {\n      targetItems.forEach((treeItem) => {\n        if (!treeItem.disabled) {\n          treeItem.selected = false;\n        }\n      });\n    } else if (!isNoneSelectionMode) {\n      targetItems.forEach((treeItem) => {\n        if (!treeItem.disabled) {\n          treeItem.selected = this.selectionMode !== \"single\" || !treeItem.selected;\n        }\n      });\n    }\n\n    this.selectedItems = isNoneSelectionMode\n      ? []\n      : nodeListToArray(this.el.querySelectorAll(\"calcite-tree-item\")).filter((i) => i.selected);\n\n    this.calciteTreeSelect.emit();\n\n    event.stopPropagation();\n  }\n\n  private keyDownHandler = (event: KeyboardEvent): void => {\n    if (this.child) {\n      return;\n    }\n\n    const root = this.el;\n    const target = event.target as HTMLCalciteTreeItemElement;\n\n    const supportedKeys = [\"ArrowRight\", \"ArrowDown\", \"ArrowLeft\", \"ArrowUp\", \"Home\", \"End\", \"Tab\"];\n\n    if (!(isTreeItem(target) && this.el.contains(target)) || !supportedKeys.includes(event.key)) {\n      return;\n    }\n\n    const traversableItems = getTraversableItems(root);\n\n    if (event.key === \"Tab\") {\n      // root tabindex will be restored when blurred/focused\n      traversableItems.forEach((item) => (item.tabIndex = -1));\n      return;\n    }\n\n    if (event.key === \"ArrowDown\") {\n      const currentItemIndex = traversableItems.indexOf(target);\n      const nextItem = traversableItems[currentItemIndex + 1];\n      nextItem?.focus();\n      event.preventDefault();\n      return;\n    }\n\n    if (event.key === \"ArrowUp\") {\n      const currentItemIndex = traversableItems.indexOf(target);\n      const previousItem = traversableItems[currentItemIndex - 1];\n      previousItem?.focus();\n      event.preventDefault();\n      return;\n    }\n\n    if (event.key === \"ArrowLeft\") {\n      if (target.hasChildren && target.expanded) {\n        target.expanded = false;\n        event.preventDefault();\n        return;\n      }\n\n      const rootToItemPath = traversableItems.slice(0, traversableItems.indexOf(target)).reverse();\n      const parentItem = rootToItemPath.find((item) => item.depth === target.depth - 1);\n\n      parentItem?.focus();\n      event.preventDefault();\n\n      return;\n    }\n\n    if (event.key === \"ArrowRight\") {\n      if (!target.disabled && target.hasChildren) {\n        if (!target.expanded) {\n          target.expanded = true;\n          event.preventDefault();\n        } else {\n          const currentItemIndex = traversableItems.indexOf(target);\n          const nextItem = traversableItems[currentItemIndex + 1];\n          nextItem?.focus();\n          event.preventDefault();\n        }\n      }\n\n      return;\n    }\n\n    if (event.key === \"Home\") {\n      const firstNode = traversableItems.shift();\n      if (firstNode) {\n        firstNode.focus();\n        event.preventDefault();\n      }\n      return;\n    }\n\n    if (event.key === \"End\") {\n      const lastNode = traversableItems.pop();\n      if (lastNode) {\n        lastNode.focus();\n        event.preventDefault();\n      }\n      return;\n    }\n  };\n\n  private updateAncestorTree(event: CustomEvent<TreeItemSelectDetail>): void {\n    const item = event.target as HTMLCalciteTreeItemElement;\n    const updateItem = event.detail.updateItem;\n\n    if (item.disabled || (item.indeterminate && !updateItem)) {\n      return;\n    }\n\n    const ancestors: HTMLCalciteTreeItemElement[] = [];\n    let parent = item.parentElement.closest<HTMLCalciteTreeItemElement>(\"calcite-tree-item\");\n    while (parent) {\n      ancestors.push(parent);\n      parent = parent.parentElement.closest<HTMLCalciteTreeItemElement>(\"calcite-tree-item\");\n    }\n\n    const childItems = Array.from(\n      item.querySelectorAll<HTMLCalciteTreeItemElement>(\"calcite-tree-item:not([disabled])\"),\n    );\n    const childItemsWithNoChildren = childItems.filter((child) => !child.hasChildren);\n    const childItemsWithChildren = childItems.filter((child) => child.hasChildren);\n\n    let futureSelected;\n    if (updateItem) {\n      futureSelected = item.hasChildren ? !(item.selected || item.indeterminate) : !item.selected;\n    } else {\n      futureSelected = item.selected;\n    }\n\n    childItemsWithNoChildren.forEach((el) => {\n      el.selected = futureSelected;\n      el.indeterminate = false;\n    });\n\n    function updateItemState(\n      childItems: HTMLCalciteTreeItemElement[],\n      item: HTMLCalciteTreeItemElement,\n    ): void {\n      const selected = childItems.filter((child) => child.selected);\n      const unselected = childItems.filter((child) => !child.selected);\n\n      item.selected = selected.length === childItems.length;\n      item.indeterminate = selected.length > 0 && unselected.length > 0;\n    }\n\n    childItemsWithChildren.reverse().forEach((el) => {\n      const directChildItems = Array.from(\n        el.querySelectorAll<HTMLCalciteTreeItemElement>(\n          \":scope > calcite-tree > calcite-tree-item\",\n        ),\n      );\n\n      updateItemState(directChildItems, el);\n    });\n\n    if (updateItem) {\n      if (item.hasChildren) {\n        updateItemState(childItems, item);\n      } else {\n        item.selected = futureSelected;\n        item.indeterminate = false;\n      }\n    }\n\n    ancestors.forEach((ancestor) => {\n      const descendants = nodeListToArray(ancestor.querySelectorAll(\"calcite-tree-item\"));\n      const activeDescendants = descendants.filter((el) => el.selected);\n      if (activeDescendants.length === 0) {\n        ancestor.selected = false;\n        ancestor.indeterminate = false;\n        return;\n      }\n\n      const indeterminate = activeDescendants.length < descendants.length;\n      ancestor.indeterminate = indeterminate;\n      ancestor.selected = !indeterminate;\n    });\n\n    this.selectedItems = nodeListToArray(this.el.querySelectorAll(\"calcite-tree-item\")).filter(\n      (i) => i.selected,\n    );\n\n    if (updateItem) {\n      this.calciteTreeSelect.emit();\n    }\n  }\n\n  //--------------------------------------------------------------------------\n  //\n  //  Events\n  //\n  //--------------------------------------------------------------------------\n\n  /**\n   * Fires when the user selects/deselects `calcite-tree-items`.\n   */\n  @Event({ cancelable: false }) calciteTreeSelect: EventEmitter<void>;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Private Properties\n  //\n  //--------------------------------------------------------------------------\n\n  @Element() el: HTMLCalciteTreeElement;\n\n  // --------------------------------------------------------------------------\n  //\n  //  Private Methods\n  //\n  //--------------------------------------------------------------------------\n\n  getRootTabIndex(): number {\n    return !this.child ? 0 : -1;\n  }\n}\n"],"names":["isTreeItem","element","tagName","Tree","proxyCustomElement","HTMLElement","keyDownHandler","event","this","child","root","el","target","contains","includes","key","traversableItems","Array","from","querySelectorAll","filter","item","currentItem","undefined","parent","parentElement","hasChildren","expanded","getTraversableItems","currentItemIndex","indexOf","nextItem","focus","preventDefault","previousItem","parentItem","slice","reverse","find","depth","lastNode","pop","firstNode","shift","disabled","forEach","tabIndex","componentWillRender","closest","lines","scale","selectionMode","render","h","Host","toAriaBoolean","onKeyDown","role","getRootTabIndex","onFocus","focusTarget","querySelector","focusElement","onFocusIn","relatedTarget","removeAttribute","onFocusOut","onInternalTreeItemSelect","childItems","nodeListToArray","stopPropagation","updateAncestorTree","isNoneSelectionMode","shouldSelect","shouldDeselectAllChildren","shouldModifyToCurrentSelection","detail","modifyCurrentSelection","shouldClearCurrentSelection","length","shouldUpdateExpand","targetItems","push","treeItem","selected","window","getSelection","removeAllRanges","selectedItems","i","calciteTreeSelect","emit","updateItem","indeterminate","ancestors","childItemsWithNoChildren","childItemsWithChildren","futureSelected","updateItemState","unselected","ancestor","descendants","activeDescendants"],"sourceRoot":""}